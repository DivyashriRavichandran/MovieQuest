{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveRequestDocument = exports.GraphQLWebSocketClient = exports.gql = exports.batchRequests = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;\nconst createRequestBody_js_1 = __importDefault(require(\"./createRequestBody.js\"));\nconst defaultJsonSerializer_js_1 = require(\"./defaultJsonSerializer.js\");\nconst helpers_js_1 = require(\"./helpers.js\");\nconst parseArgs_js_1 = require(\"./parseArgs.js\");\nconst resolveRequestDocument_js_1 = require(\"./resolveRequestDocument.js\");\nconst types_js_1 = require(\"./types.js\");\nObject.defineProperty(exports, \"ClientError\", {\n  enumerable: true,\n  get: function () {\n    return types_js_1.ClientError;\n  }\n});\nconst cross_fetch_1 = __importStar(require(\"cross-fetch\")),\n  CrossFetch = cross_fetch_1;\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = headers => {\n  let oHeaders = {};\n  if (headers) {\n    if (typeof Headers !== `undefined` && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {\n      oHeaders = (0, helpers_js_1.HeadersInstanceToPlainObject)(headers);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value;\n        }\n      });\n    } else {\n      oHeaders = headers;\n    }\n  }\n  return oHeaders;\n};\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = str => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim();\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = params => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params;\n    const search = [`query=${encodeURIComponent(cleanQuery(params_.query))}`];\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`);\n    }\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`);\n    }\n    return search.join(`&`);\n  }\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`);\n  }\n  // Batch support\n  const params_ = params;\n  const payload = params.query.reduce((acc, currentQuery, index) => {\n    acc.push({\n      query: cleanQuery(currentQuery),\n      variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined\n    });\n    return acc;\n  }, []);\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`;\n};\nconst createHttpMethodFetcher = method => async params => {\n  const {\n    url,\n    query,\n    variables,\n    operationName,\n    fetch,\n    fetchOptions,\n    middleware\n  } = params;\n  const headers = {\n    ...params.headers\n  };\n  let queryParams = ``;\n  let body = undefined;\n  if (method === `POST`) {\n    body = (0, createRequestBody_js_1.default)(query, variables, operationName, fetchOptions.jsonSerializer);\n    if (typeof body === `string`) {\n      // @ts-expect-error todo\n      headers[`Content-Type`] = `application/json`;\n    }\n  } else {\n    // @ts-expect-error todo needs ADT for TS to understand the different states\n    queryParams = buildRequestConfig({\n      query,\n      variables,\n      operationName,\n      jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer_js_1.defaultJsonSerializer\n    });\n  }\n  const init = {\n    method,\n    headers,\n    body,\n    ...fetchOptions\n  };\n  let urlResolved = url;\n  let initResolved = init;\n  if (middleware) {\n    const result = await Promise.resolve(middleware({\n      ...init,\n      url,\n      operationName,\n      variables\n    }));\n    const {\n      url: urlNew,\n      ...initNew\n    } = result;\n    urlResolved = urlNew;\n    initResolved = initNew;\n  }\n  if (queryParams) {\n    urlResolved = `${urlResolved}?${queryParams}`;\n  }\n  return await fetch(urlResolved, initResolved);\n};\n/**\n * GraphQL Client.\n */\nclass GraphQLClient {\n  constructor(url, requestConfig = {}) {\n    this.url = url;\n    this.requestConfig = requestConfig;\n    /**\n     * Send a GraphQL query to the server.\n     */\n    this.rawRequest = async (...args) => {\n      const [queryOrOptions, variables, requestHeaders] = args;\n      const rawRequestOptions = (0, parseArgs_js_1.parseRawRequestArgs)(queryOrOptions, variables, requestHeaders);\n      const {\n        headers,\n        fetch = cross_fetch_1.default,\n        method = `POST`,\n        requestMiddleware,\n        responseMiddleware,\n        ...fetchOptions\n      } = this.requestConfig;\n      const {\n        url\n      } = this;\n      if (rawRequestOptions.signal !== undefined) {\n        fetchOptions.signal = rawRequestOptions.signal;\n      }\n      const {\n        operationName\n      } = (0, resolveRequestDocument_js_1.resolveRequestDocument)(rawRequestOptions.query);\n      return makeRequest({\n        url,\n        query: rawRequestOptions.query,\n        variables: rawRequestOptions.variables,\n        headers: {\n          ...resolveHeaders(callOrIdentity(headers)),\n          ...resolveHeaders(rawRequestOptions.requestHeaders)\n        },\n        operationName,\n        fetch,\n        method,\n        fetchOptions,\n        middleware: requestMiddleware\n      }).then(response => {\n        if (responseMiddleware) {\n          responseMiddleware(response);\n        }\n        return response;\n      }).catch(error => {\n        if (responseMiddleware) {\n          responseMiddleware(error);\n        }\n        throw error;\n      });\n    };\n  }\n  async request(documentOrOptions, ...variablesAndRequestHeaders) {\n    const [variables, requestHeaders] = variablesAndRequestHeaders;\n    const requestOptions = (0, parseArgs_js_1.parseRequestArgs)(documentOrOptions, variables, requestHeaders);\n    const {\n      headers,\n      fetch = cross_fetch_1.default,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig;\n    const {\n      url\n    } = this;\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal;\n    }\n    const {\n      query,\n      operationName\n    } = (0, resolveRequestDocument_js_1.resolveRequestDocument)(requestOptions.document);\n    return makeRequest({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders)\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware\n    }).then(response => {\n      if (responseMiddleware) {\n        responseMiddleware(response);\n      }\n      return response.data;\n    }).catch(error => {\n      if (responseMiddleware) {\n        responseMiddleware(error);\n      }\n      throw error;\n    });\n  }\n  // prettier-ignore\n  batchRequests(documentsOrOptions, requestHeaders) {\n    const batchRequestOptions = (0, parseArgs_js_1.parseBatchRequestArgs)(documentsOrOptions, requestHeaders);\n    const {\n      headers,\n      ...fetchOptions\n    } = this.requestConfig;\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal;\n    }\n    const queries = batchRequestOptions.documents.map(({\n      document\n    }) => (0, resolveRequestDocument_js_1.resolveRequestDocument)(document).query);\n    const variables = batchRequestOptions.documents.map(({\n      variables\n    }) => variables);\n    return makeRequest({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders)\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? cross_fetch_1.default,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware\n    }).then(response => {\n      if (this.requestConfig.responseMiddleware) {\n        this.requestConfig.responseMiddleware(response);\n      }\n      return response.data;\n    }).catch(error => {\n      if (this.requestConfig.responseMiddleware) {\n        this.requestConfig.responseMiddleware(error);\n      }\n      throw error;\n    });\n  }\n  setHeaders(headers) {\n    this.requestConfig.headers = headers;\n    return this;\n  }\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key, value) {\n    const {\n      headers\n    } = this.requestConfig;\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-ignore\n      headers[key] = value;\n    } else {\n      this.requestConfig.headers = {\n        [key]: value\n      };\n    }\n    return this;\n  }\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value) {\n    this.url = value;\n    return this;\n  }\n}\nexports.GraphQLClient = GraphQLClient;\nconst makeRequest = async params => {\n  const {\n    query,\n    variables,\n    fetchOptions\n  } = params;\n  const fetcher = createHttpMethodFetcher((0, helpers_js_1.uppercase)(params.method ?? `post`));\n  const isBatchingQuery = Array.isArray(params.query);\n  const response = await fetcher(params);\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer_js_1.defaultJsonSerializer);\n  const successfullyReceivedData = Array.isArray(result) ? !result.some(({\n    data\n  }) => !data) : Boolean(result.data);\n  const successfullyPassedErrorPolicy = Array.isArray(result) || !result.errors || Array.isArray(result.errors) && !result.errors.length || fetchOptions.errorPolicy === `all` || fetchOptions.errorPolicy === `ignore`;\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const {\n      errors,\n      ...rest\n    } = Array.isArray(result) ? result : result;\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result;\n    const dataEnvelope = isBatchingQuery ? {\n      data\n    } : data;\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status\n    };\n  } else {\n    const errorResult = typeof result === `string` ? {\n      error: result\n    } : result;\n    throw new types_js_1.ClientError(\n    // @ts-expect-error TODO\n    {\n      ...errorResult,\n      status: response.status,\n      headers: response.headers\n    }, {\n      query,\n      variables\n    });\n  }\n};\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nconst rawRequest = async (...args) => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args;\n  const requestOptions = (0, parseArgs_js_1.parseRawRequestExtendedArgs)(urlOrOptions, query, ...variablesAndRequestHeaders);\n  const client = new GraphQLClient(requestOptions.url);\n  return client.rawRequest({\n    ...requestOptions\n  });\n};\nexports.rawRequest = rawRequest;\nasync function request(urlOrOptions,\n// @ts-ignore\ndocument, ...variablesAndRequestHeaders) {\n  // @ts-ignore\n  const requestOptions = (0, parseArgs_js_1.parseRequestExtendedArgs)(urlOrOptions, document, ...variablesAndRequestHeaders);\n  const client = new GraphQLClient(requestOptions.url);\n  return client.request({\n    ...requestOptions\n  });\n}\nexports.request = request;\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nconst batchRequests = async (...args) => {\n  const params = parseBatchRequestsArgsExtended(args);\n  const client = new GraphQLClient(params.url);\n  return client.batchRequests(params);\n};\nexports.batchRequests = batchRequests;\nconst parseBatchRequestsArgsExtended = args => {\n  if (args.length === 1) {\n    return args[0];\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined\n    };\n  }\n};\nexports.default = request;\nconst getResult = async (response, jsonSerializer) => {\n  let contentType;\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value;\n    }\n  });\n  if (contentType && (contentType.toLowerCase().startsWith(`application/json`) || contentType.toLowerCase().startsWith(`application/graphql+json`) || contentType.toLowerCase().startsWith(`application/graphql-response+json`))) {\n    return jsonSerializer.parse(await response.text());\n  } else {\n    return response.text();\n  }\n};\nconst callOrIdentity = value => {\n  return typeof value === `function` ? value() : value;\n};\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nconst gql = (chunks, ...variables) => {\n  return chunks.reduce((accumulator, chunk, index) => `${accumulator}${chunk}${index in variables ? variables[index] : ``}`, ``);\n};\nexports.gql = gql;\nvar graphql_ws_js_1 = require(\"./graphql-ws.js\");\nObject.defineProperty(exports, \"GraphQLWebSocketClient\", {\n  enumerable: true,\n  get: function () {\n    return graphql_ws_js_1.GraphQLWebSocketClient;\n  }\n});\nvar resolveRequestDocument_js_2 = require(\"./resolveRequestDocument.js\");\nObject.defineProperty(exports, \"resolveRequestDocument\", {\n  enumerable: true,\n  get: function () {\n    return resolveRequestDocument_js_2.resolveRequestDocument;\n  }\n});","map":{"version":3,"names":["createRequestBody_js_1","__importDefault","require","defaultJsonSerializer_js_1","helpers_js_1","parseArgs_js_1","resolveRequestDocument_js_1","types_js_1","Object","defineProperty","exports","enumerable","get","ClientError","cross_fetch_1","__importStar","CrossFetch","resolveHeaders","headers","oHeaders","Headers","HeadersInstanceToPlainObject","Array","isArray","forEach","name","value","undefined","cleanQuery","str","replace","trim","buildRequestConfig","params","query","params_","search","encodeURIComponent","variables","push","jsonSerializer","stringify","operationName","join","Error","payload","reduce","acc","currentQuery","index","createHttpMethodFetcher","method","url","fetch","fetchOptions","middleware","queryParams","body","default","defaultJsonSerializer","init","urlResolved","initResolved","result","Promise","resolve","urlNew","initNew","GraphQLClient","constructor","requestConfig","rawRequest","args","queryOrOptions","requestHeaders","rawRequestOptions","parseRawRequestArgs","requestMiddleware","responseMiddleware","signal","resolveRequestDocument","makeRequest","callOrIdentity","then","response","catch","error","request","documentOrOptions","variablesAndRequestHeaders","requestOptions","parseRequestArgs","document","data","batchRequests","documentsOrOptions","batchRequestOptions","parseBatchRequestArgs","queries","documents","map","setHeaders","setHeader","key","setEndpoint","fetcher","uppercase","isBatchingQuery","getResult","successfullyReceivedData","some","Boolean","successfullyPassedErrorPolicy","errors","length","errorPolicy","ok","rest","dataEnvelope","status","errorResult","urlOrOptions","parseRawRequestExtendedArgs","client","parseRequestExtendedArgs","parseBatchRequestsArgsExtended","contentType","toLowerCase","startsWith","parse","text","gql","chunks","accumulator","chunk","graphql_ws_js_1","GraphQLWebSocketClient","resolveRequestDocument_js_2"],"sources":["/Users/divyashriravichandran/Desktop/Web Dev/Movie Info App/movie-info-app/node_modules/graphql-request/src/index.ts"],"sourcesContent":["import createRequestBody from './createRequestBody.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js'\nimport {\n  parseBatchRequestArgs,\n  parseRawRequestArgs,\n  parseRawRequestExtendedArgs,\n  parseRequestArgs,\n  parseRequestExtendedArgs,\n} from './parseArgs.js'\nimport { resolveRequestDocument } from './resolveRequestDocument.js'\nimport type * as Dom from './types.dom.js'\nimport type {\n  HTTPMethodInput,\n  MaybeFunction,\n  RequestConfig,\n  RequestMiddleware,\n  Response,\n  VariablesAndRequestHeadersArgs,\n} from './types.js'\nimport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n} from './types.js'\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport crossFetch, * as CrossFetch from 'cross-fetch'\nimport type { T, V } from 'vitest/dist/types-7cd96283.js'\n\nexport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n}\n\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = (headers: Dom.RequestInit['headers']): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n  if (headers) {\n    if (\n      (typeof Headers !== `undefined` && headers instanceof Headers) ||\n      (CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers)\n    ) {\n      oHeaders = HeadersInstanceToPlainObject(headers)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value\n        }\n      })\n    } else {\n      oHeaders = headers as Record<string, string>\n    }\n  }\n\n  return oHeaders\n}\n\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = (str: string): string => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim()\n\ntype BuildRequestConfigParamsBatch<V> = {\n  query: string[]\n  variables: V[] | undefined\n  operationName: undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParamsSingle<V> = {\n  query: string\n  variables: V | undefined\n  operationName: string | undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParams<V> = BuildRequestConfigParamsSingle<V> | BuildRequestConfigParamsBatch<V>\n\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = <V extends Variables>(params: BuildRequestConfigParams<V>): string => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params as BuildRequestConfigParamsSingle<V>\n    const search: string[] = [`query=${encodeURIComponent(cleanQuery(params_.query))}`]\n\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`)\n    }\n\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`)\n    }\n\n    return search.join(`&`)\n  }\n\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`)\n  }\n\n  // Batch support\n  const params_ = params as BuildRequestConfigParamsBatch<V>\n  const payload = params.query.reduce<{ query: string; variables: string | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({\n        query: cleanQuery(currentQuery),\n        variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined,\n      })\n      return acc\n    },\n    []\n  )\n\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`\n}\n\ntype Fetch = (url: string, config: Dom.RequestInit) => Promise<Dom.Response>\n\ninterface RequestVerbParams<V extends Variables = Variables> {\n  url: string\n  query: string | string[]\n  fetch: Fetch\n  fetchOptions: Dom.RequestInit\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  middleware?: RequestMiddleware<V>\n}\n\nconst createHttpMethodFetcher =\n  (method: 'GET' | 'POST') =>\n  async <V extends Variables>(params: RequestVerbParams<V>) => {\n    const { url, query, variables, operationName, fetch, fetchOptions, middleware } = params\n\n    const headers = { ...params.headers }\n    let queryParams = ``\n    let body = undefined\n\n    if (method === `POST`) {\n      body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer)\n      if (typeof body === `string`) {\n        // @ts-expect-error todo\n        headers[`Content-Type`] = `application/json`\n      }\n    } else {\n      // @ts-expect-error todo needs ADT for TS to understand the different states\n      queryParams = buildRequestConfig<V>({\n        query,\n        variables,\n        operationName,\n        jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n      })\n    }\n\n    const init: Dom.RequestInit = {\n      method,\n      headers,\n      body,\n      ...fetchOptions,\n    }\n\n    let urlResolved = url\n    let initResolved = init\n    if (middleware) {\n      const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }))\n      const { url: urlNew, ...initNew } = result\n      urlResolved = urlNew\n      initResolved = initNew\n    }\n    if (queryParams) {\n      urlResolved = `${urlResolved}?${queryParams}`\n    }\n    return await fetch(urlResolved, initResolved)\n  }\n\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  constructor(private url: string, public readonly requestConfig: RequestConfig = {}) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <T, V extends Variables = Variables>(\n    ...args: RawRequestMethodArgs<V>\n  ): Promise<Response<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<V>(queryOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const { operationName } = resolveRequestDocument(rawRequestOptions.query)\n\n    return makeRequest<T, V>({\n      url,\n      query: rawRequestOptions.query,\n      variables: rawRequestOptions.variables as V,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(rawRequestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  async request<T, V extends Variables = Variables>(\n    document: RequestDocument | TypedDocumentNode<T, V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions: RequestDocument | TypedDocumentNode<T, V> | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const { query, operationName } = resolveRequestDocument(requestOptions.document)\n\n    return makeRequest<T>({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsOptions<V>): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(\n    documentsOrOptions: BatchRequestDocument<V>[] | BatchRequestsOptions<V>,\n    requestHeaders?: Dom.RequestInit['headers']\n  ): Promise<T> {\n    const batchRequestOptions = parseBatchRequestArgs<V>(documentsOrOptions, requestHeaders)\n    const { headers, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const queries = batchRequestOptions.documents.map(\n      ({ document }) => resolveRequestDocument(document).query\n    )\n    const variables = batchRequestOptions.documents.map(({ variables }) => variables)\n\n    return makeRequest<T>({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders),\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n      .then((response) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  setHeaders(headers: Dom.RequestInit['headers']): GraphQLClient {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): GraphQLClient {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-ignore\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): GraphQLClient {\n    this.url = value\n    return this\n  }\n}\n\nconst makeRequest = async <T = unknown, V extends Variables = Variables>(params: {\n  url: string\n  query: string | string[]\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  fetch: Fetch\n  method?: HTTPMethodInput\n  fetchOptions: Dom.RequestInit\n  middleware?: RequestMiddleware<V>\n}): Promise<Response<T>> => {\n  const { query, variables, fetchOptions } = params\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`))\n  const isBatchingQuery = Array.isArray(params.query)\n  const response = await fetcher(params)\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer)\n\n  const successfullyReceivedData = Array.isArray(result)\n    ? !result.some(({ data }) => !data)\n    : Boolean(result.data)\n\n  const successfullyPassedErrorPolicy =\n    Array.isArray(result) ||\n    !result.errors ||\n    (Array.isArray(result.errors) && !result.errors.length) ||\n    fetchOptions.errorPolicy === `all` ||\n    fetchOptions.errorPolicy === `ignore`\n\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const { errors, ...rest } = Array.isArray(result) ? result : result\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result\n    const dataEnvelope = isBatchingQuery ? { data } : data\n\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status,\n    }\n  } else {\n    const errorResult =\n      typeof result === `string`\n        ? {\n            error: result,\n          }\n        : result\n    throw new ClientError(\n      // @ts-expect-error TODO\n      { ...errorResult, status: response.status, headers: response.headers },\n      { query, variables }\n    )\n  }\n}\n\n// prettier-ignore\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']]\n  | [RawRequestOptions<V>]\n\n// prettier-ignore\ninterface RawRequest {\n  <T, V extends Variables = Variables>(url: string, query: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestExtendedOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestArgs<V extends Variables> = \n  | [options: RawRequestExtendedOptions<V>, query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n  | [url: string,                           query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nexport const rawRequest: RawRequest = async <T, V extends Variables>(\n  ...args: RawRequestArgs<V>\n): Promise<Response<T>> => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args\n  const requestOptions = parseRawRequestExtendedArgs<V>(urlOrOptions, query, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.rawRequest<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await request('https://foo.bar/graphql', `\n *   {\n *     query {\n *       users\n *     }\n *   }\n * `)\n *\n * // You can also pass a GraphQL DocumentNode. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * // If you don't actually care about using DocumentNode but just\n * // want the tooling support for gql template tag like IDE syntax\n * // coloring and prettier autoformat then note you can use the\n * // passthrough gql tag shipped with graphql-request to save a bit\n * // of performance and not have to install another dep into your project.\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n */\nexport async function request<T, V extends Variables = Variables>(\n  url: string,\n  // @ts-ignore\n  document: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  options: RequestExtendedOptions<V, T>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  urlOrOptions: string | RequestExtendedOptions<V, T>,\n  // @ts-ignore\n  document?: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T> {\n  // @ts-ignore\n  const requestOptions = parseRequestExtendedArgs<V>(urlOrOptions, document, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.request<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nexport const batchRequests: BatchRequests = async (...args: BatchRequestsArgs) => {\n  const params = parseBatchRequestsArgsExtended(args)\n  const client = new GraphQLClient(params.url)\n  return client.batchRequests(params)\n}\n\ninterface Result<Data extends object = object> {\n  data: Data\n}\n\ntype BatchResult = [Result, ...Result[]]\n\n// prettier-ignore\ninterface BatchRequests {\n  <T extends BatchResult, V extends Variables = Variables>(url: string, documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  <T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsExtendedOptions<V>): Promise<T>\n}\n\ntype BatchRequestsArgs =\n  | [url: string, documents: BatchRequestDocument[], requestHeaders?: Dom.RequestInit['headers']]\n  | [options: BatchRequestsExtendedOptions]\n\nconst parseBatchRequestsArgsExtended = (args: BatchRequestsArgs): BatchRequestsExtendedOptions => {\n  if (args.length === 1) {\n    return args[0]\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined,\n    }\n  }\n}\n\nexport default request\n\nconst getResult = async (\n  response: Dom.Response,\n  jsonSerializer: Dom.JsonSerializer\n): Promise<\n  | { data: object; errors: undefined }[]\n  | { data: object; errors: undefined }\n  | { data: undefined; errors: object }\n  | { data: undefined; errors: object[] }\n> => {\n  let contentType: string | undefined\n\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value\n    }\n  })\n\n  if (\n    contentType &&\n    (contentType.toLowerCase().startsWith(`application/json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql+json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql-response+json`))\n  ) {\n    return jsonSerializer.parse(await response.text()) as any\n  } else {\n    return response.text() as any\n  }\n}\n\nconst callOrIdentity = <T>(value: MaybeFunction<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks: TemplateStringsArray, ...variables: any[]): string => {\n  return chunks.reduce(\n    (accumulator, chunk, index) => `${accumulator}${chunk}${index in variables ? variables[index] : ``}`,\n    ``\n  )\n}\n\nexport { GraphQLWebSocketClient } from './graphql-ws.js'\nexport { resolveRequestDocument } from './resolveRequestDocument.js'\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}